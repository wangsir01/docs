

# 安卓root检测常见手段 - 先知社区

安卓root检测常见手段

* * *

# 一、root检测常见手段

1.目录特征遍历 我们来看段检测代码，从代码中可以看会去遍历"/sbin/su", "/system/bin/su", "/system/sbin/su", "/system/xbin/su" 等目录其次检测magsik、SuperSU等特征。  
2.尝试执行root后的一些操作 对特定目录尝试新建文件例如 /data、/system、/etc 等（只有root后才有权限操作的目录），或者去执行典型的，例如su，还有find、mount等命令。  
3.读取手机编译版本、调试状态 例如读取/system/build.prop中 是test-keys（测试版），还是release-keys（发布版)，去获取ro.debuggable、ro.secure的值检测是否有调试状态  
4.root检测指纹

```plain
1.detectRootManagementApps—检测常见su包名,如{“com.noshufou.android.su”, “com.noshufou.android.su.elite”, “eu.chainfire.supersu”, “com.koushikdutta.superuser”, “com.thirdparty.superuser”, “com.yellowes.su”, “com.topjohnwu.magisk”, “com.kingroot.kinguser”, “com.kingo.root”, “com.smedialink.oneclickroot”, “com.zhiqupk.root.global”, “com.alephzain.framaroot”}

2.detectPotentiallyDangerousApps—{“com.koushikdutta.rommanager”, “com.koushikdutta.rommanager.license”, “com.dimonvideo.luckypatcher”, “com.chelpus.lackypatch”, “com.ramdroid.appquarantine”, “com.ramdroid.appquarantinepro”, “com.android.vending.billing.InAppBillingService.COIN”, “com.android.vending.billing.InAppBillingService.LUCK”, “com.chelpus.luckypatcher”, “com.blackmartalpha”, “org.blackmart.market”, “com.allinone.free”, “com.repodroid.app”, “org.creeplays.hack”, “com.baseappfull.fwd”, “com.zmapp”, “com.dv.marketmod.installer”, “org.mobilism.android”, “com.android.wp.net.log”, “com.android.camera.update”, “cc.madkite.freedom”, “com.solohsu.android.edxp.manager”, “org.meowcat.edxposed.manager”, “com.xmodgame”, “com.cih.game_cih”, “com.charles.lpoqasert”, “catch_.me_.if_.you_.can_”}

3.detectRootCloakingApps—{“com.devadvance.rootcloak”, “com.devadvance.rootcloakplus”, “de.robv.android.xposed.installer”, “com.saurik.substrate”, “com.zachspong.temprootremovejb”, “com.amphoras.hidemyroot”, “com.amphoras.hidemyrootadfree”, “com.formyhm.hiderootPremium”, “com.formyhm.hideroot”}

4.suPath—遍历执行可能存在的su文件夹,如{“/data/local/”, “/data/local/bin/”, “/data/local/xbin/”, “/sbin/”, “/su/bin/”, “/system/bin/”, “/system/bin/.ext/”, “/system/bin/failsafe/”, “/system/sd/xbin/”, “/system/usr/we-need-root/”, “/system/xbin/”, “/cache/”, “/data/”, “/dev/”}

5.checkForDangerousProps—检查一些属性的值.{ro.debuggable”, “1”},{“ro.secure”, “0”}

6.checkForRWPaths—先执行(需要root)mount如果返回true然后再查看是否有读写权限{“/system”, “/system/bin”, “/system/sbin”, “/system/xbin”, “/vendor/bin”, “/sbin”, “/etc”}

7.detectTestKeys—查看编译类型是否为 {“test-keys”}

8.checkBuildProp—检查Buildprop的值,{“ro.build.display.id”,”ro.build.version.incremental”,”ro.build.date”,”ro.build.date.utc”,”ro.build.type”,”ro.build.user”,”ro.build.flavor”,”ro.build.tags”,”ro.build.description”,”ro.build.fingerprint”,”ro.product.model”,”ro.product.brand”,”ro.product.name”}

9.checkSuExists—执行su,看看能否执行成功

10.checkForRootNative—Native层root检查

11.checkForMagiskBinary—检测是否存在Magisk-{“/data/local/”, “/data/local/bin/”, “/data/local/xbin/”, “/sbin/”, “/su/bin/”, “/system/bin/”, “/system/bin/.ext/”, “/system/bin/failsafe/”, “/system/sd/xbin/”, “/system/usr/we-need-root/”, “/system/xbin/”, “/cache/”, “/data/”, “/dev/”}
```

## 二、方案

### 一、修改su名字

#### 1、环境

安卓8源码

#### 2、自定义su名

/system/extras/su/Android.mk中修改su为需要的名称

[![](assets/1701606958-e8c77a770b185dbf4ceb488580c1639b.png)](https://xzfile.aliyuncs.com/media/upload/picture/20231007084816-3401481e-64ab-1.png)

#### 3、/system/core/libcutils/fs\_config.cpp中/system/xbin/su修改为/system/xbin/修改的名称

[![](assets/1701606958-aed33dc74e227ccda030dbae32f2bfb0.png)](https://xzfile.aliyuncs.com/media/upload/picture/20231007084836-3fcec41e-64ab-1.png)

#### 4、/system/sepolicy/private/file\_contexts中/system/xbin/su修改为/system/xbin/修改的名称

[![](assets/1701606958-fb23946f26212d502c6c002678c6c6a3.png)](https://xzfile.aliyuncs.com/media/upload/picture/20231007084842-42fc17a4-64ab-1.png)

#### 5、去除指纹

ro.build.tags=test-keys被写入在system/build.prop文件，我们查看这个文件看到autogenerated by buildinfo.sh 是被buildinfo.sh文件写入的，我们找下这个文件 在/build/make/tools/buildinfo.sh ro.build.tags的值是读取BUILD\_VERSION\_TAGS 而BUILD\_VERSION\_TAGS 则是/build/core/Makefile 中BUILD\_KEYS 给的值，所以我们将 test-keys 改为 release-keys即可

[![](assets/1701606958-0bef42e9088ca51a463f57d52c734e29.png)](https://xzfile.aliyuncs.com/media/upload/picture/20231007084849-4798cf32-64ab-1.png)

[![](assets/1701606958-c3cef06b30855fccf9bac3ad4f9aa634.png)](https://xzfile.aliyuncs.com/media/upload/picture/20231007084855-4b29b40e-64ab-1.png)

更改后test-keys均变成了release-keys。  
虽然我们改了test-keys 但是ro.build.type、ro.build.display.id、ro.build.flavor、 ro.build.description、ro.build.fingerprint标签中均有userdebug,发布版值应为user 我们先 看下ro.build.type对应的值是来自TARGET\_BUILD\_TYPE

[![](assets/1701606958-fec9440db080be7dd70c399742a1ba2d.png)](https://xzfile.aliyuncs.com/media/upload/picture/20231007084907-51da7eb4-64ab-1.png)

TARGET\_BUILD\_TYPE 的值又是TARGET\_BUILD\_VARIANT，又索引到其他文件去了，为了减少出错率，我们就在这里直接赋值user  
/aosp810r1/aosp810r1/build/core/Makefile

[![](assets/1701606958-8ef76dda434f1255c5069e64d8d624c6.png)](https://xzfile.aliyuncs.com/media/upload/picture/20231007084915-56b8e61e-64ab-1.png)

/aosp810r1/aosp810r1/build/make/tools/buildinfo.sh

[![](assets/1701606958-e57f258c353338d906a6ffe1e83949c8.png)](https://xzfile.aliyuncs.com/media/upload/picture/20231007084921-5abc7c58-64ab-1.png)

aosp810r1/aosp810r1/build/core/Makefile

[![](assets/1701606958-a63c4bef697f73bf2936cf92e9058a15.png)](https://xzfile.aliyuncs.com/media/upload/picture/20231007084928-5e648940-64ab-1.png)

TARGET\_BUILD\_FLAVOR := $(TARGET\_PRODUCT)-$(TARGET\_BUILD\_VARIANT)我们对比下值就可以判断出 TARGET\_BUILD\_VARIANT 就是userdebug字符串。直接改成TARGET\_BUILD\_FLAVOR := $(TARGET\_PRODUCT)-user  
接下来根据root检测指纹8去修改即可

### 二、直接赋予adb为root权限

#### 1、环境

adb 的root 权限是在system/core/adb/adb.c 中控制。主要根据ro.secure 以及 ro.debuggable 等system property 来控制。  
默认即档ro.secure 为0 时，即开启root 权限，为1时再根据ro.debuggable 等选项来确认是否可以用开启root 权限。为此如果要永久性开启adb 的root 权限，有两种修改的方式:

1.  修改system property ro.secure， 让ro.secure=0。
2.  修改adb.c 中开启root 权限的判断逻辑。  
    以安卓8为例  
    \#### 2、修改  
    #####（1）方法一 修改system property ro.secure， 让ro.secure=0  
    1、修改aosp810r1/build/core/main.mk

[![](assets/1701606958-08790ac3442d62a32937e887b75c96b0.png)](https://xzfile.aliyuncs.com/media/upload/picture/20231007085053-910cab2a-64ab-1.png)

将ADDITIONAL\_DEFAULT\_PROPERTIES += ro.secure=1 改成ADDITIONAL\_DEFAULT\_PROPERTIES += ro.secure=0  
2、修改aosp810r1/system/core/adb/Android.mk  
google 从编译上直接去除了adbd 的user 版本root 权限， 为此需要修改system/core/adb/Android.mk 中的编译选项ALLOW\_ADBD\_ROOT, 如果没有打开这个选项，那么adb.c 中将不会根据ro.secure 去选择root 还是shell 权限，直接返回shell 权限。

[![](assets/1701606958-6312b7eb4f2344e0b7cf951d951f41c0.png)](https://xzfile.aliyuncs.com/media/upload/picture/20231007085100-9592dd18-64ab-1.png)

将ifneq (,$(filter userdebug eng,$(TARGET\_BUILD\_VARIANT)))换成ifneq (,$(filter userdebug user eng,$(TARGET\_BUILD\_VARIANT)))  
3、修改aosp810r1/system/sepolicy/Android.mk

[![](assets/1701606958-7a709f2cc67f3bcf1e4c2d848c6a9dc7.png)](https://xzfile.aliyuncs.com/media/upload/picture/20231007085107-9959330c-64ab-1.png)

将两行exit 1；注释掉。

##### （2）方法二 修改should\_drop\_privileges() 函数

[![](assets/1701606958-5906dc3f253baaa51b5dd49f58154aeb.png)](https://xzfile.aliyuncs.com/media/upload/picture/20231007085113-9cf16354-64ab-1.png)

在aosp810r1/system/core/adb/daemon/main.cpp中将should\_drop\_privileges函数清空，直接返回0。返回0 即开启root 权限。

#### 3、去掉编译指纹

根据前面的去除指纹进行清除。
