

# 奇安信攻防社区-【Web实战】 Atlassian Confluence CVE-2023-22518/22515 Getshell 速通

### 【Web实战】 Atlassian Confluence CVE-2023-22518/22515 Getshell 速通

对 CVE-2023-22518 的一波分析

# 前言&&参考

前阵子爆出来的评分10.0的Confluence未授权漏洞可谓是比较震撼的，但其实漏洞原理不算复杂，利用的是XframeWork2的getter特性。具体分析可以参考我的往期文章  
[Atlassian Confluence CVE-2023-22515 深入浅出 - Boogiepop Doesn’t Laugh](https://boogipop.com/2023/10/16/Atlassian%20Confluence%20CVE-2023-22515%20%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA/)  
然后有一些外国佬发了一些不全的验证性质的POC，没有EXP  
[https://github.com/davidfortytwo/CVE-2023-22518/blob/main/CVE-2023-22518.py](https://github.com/davidfortytwo/CVE-2023-22518/blob/main/CVE-2023-22518.py)  
我就浅浅的分析一下。

# 漏洞分析

但只需要给出漏洞的路由，我们就可以进一步去分析，这个POC中给出的路由是  
`/json/setup-restore.action`  
我们直接到structs.xml文件中去寻找相关的路由  
!\[image.png\]

![image.png](assets/1699928972-e32fb3b9edcf848b2f0b415950a7f365.png)  
这乍一看就发现了一个Action，进去看看逻辑

![image.png](assets/1699928972-f80091cfb980d042503843e3969c1c3c.png)  
这个接口没有进行鉴权，并且我们可以触发validate方法，他会获取请求体中上传的File，然后带入`getExportDescriptor`方法

![image.png](assets/1699928972-2d69d76f1e1e79a445232d692f6cd846.png)  
在这里可以看到参数名是Zip，不难想到让我们上传一个zip文件。  
![image.png](assets/1699928972-fb4c3de809cc4bdb99a678b07e7fb89b.png)  
随后创建一个解压类unzipper

![image.png](assets/1699928972-b573a68a896dd6fed2aec20583c37279.png)  
进行解压操作

![image.png](assets/1699928972-e85898700a42b81bc06830c45eec8c7f.png)

![image.png](assets/1699928972-64d4e7cebd762c4d3d167c3010a1277c.png)  
进入saveEntry看看

![image.png](assets/1699928972-26d9cd3116a5042be8cff2cdc1d622d3.png)  
一开始我以为是zipslip，所以有了下面一个失败的尝试

# 调试流程分析

![image.png](assets/1699928972-5a595004e708774d85d466aa002902f9.png)

![image.png](assets/1699928972-c2e12dc8b34fb4c213ab814d0d6a7a15.png)

进入我们的断点了已经，这里有个细节，就是我们需要给header加一个  
`X-Atlassian-Token=no-check`  
往前看堆栈

![image.png](assets/1699928972-c5e2c53da3106145616e7d6316450cb9.png)  
有一个isProtected属性，是由methodRequiresProtection方法赋值的

![image.png](assets/1699928972-9cdc648bbd650e291935135a736ce59a.png)  
isOverrideHeaderPresent方法

![image.png](assets/1699928972-c17e1494355316c0209cbde64b8c50e8.png)  
这样isProtected属性就为false了

![image.png](assets/1699928972-7d08d6f20ded1e336c8fb0c099d624fb.png)  
因此我们才有接下来的调用哦。那我们继续看解压流程

![image.png](assets/1699928972-b12f75b0d5617ca7a526ec4a43a5bbc5.png)  
在这里会创建一个缓存文件夹，存放zip的位置

![image.png](assets/1699928972-7ce92a8c032403944b5168647195d38b.png)  
确实是有这东西，继续往下看

![image.png](assets/1699928972-cac1ea66a1379075515b263bbc38f5e2.png)  
这里会读取zip文件里有没有exportDescriptor.properties这个文件

![image.png](assets/1699928972-9516ff563610e7e08ab53671c76d40e8.png)  
这里我的zip文件并没有他，因此就寄掉了，我们加上这个文件再来一遍

![image.png](assets/1699928972-7331f982ac6b856cfe3dfdc103e5c28d.png)  
很好这次是成功获取咯。  
然后经过多次尝试，properties有几个必要的属性

-   exportType
-   createdByBuildNumber
-   buildNumber

其中我们要让exportType=ALL，这样才可以进入接下来的execute流程  
并且这个zip需要一个entities.xml，而且这个entities.xml需要一定的配置，到这里我就去网上搜了一下这个文件，然后才知道，哦，原来这就是confluence的备份文件zip

![image.png](assets/1699928972-2529f5af7e36dbde10035228b2a9ab75.png)  
然后这个也就是数据恢复接口未授权访问。恍然大悟的我发现哪里来的那么多操作，直接自己本地准备个备份文件，然后给目标上传复原，管理员密码就是自己的了。  
对于这个路由为什么是未授权的，其实就是stucts.xml配置错误问题了

![image.png](assets/1699928972-9c19c9e55b2c9862968ce0968273b250.png)  
`/json`路由继承了admin路由，导致不需要鉴权也可以访问管理员权限的接口

![image.png](assets/1699928972-f1bf6f6c66e1f4345830e2ff42328f56.png)  
我们直接post界面请求就可以进入该界面了。

# 正确的Getshell方法

这里我准备2个confluence，一个搭建在我的虚拟机里，一个搭建在本地

> 虚拟机管理员用户密码为  
> kino/kino123  
> 本机管理员用户密码为  
> admin/admin

我们现在需要做的事利用本机的confluence获取一份备份文件，鉴于严谨，这边选择把版本对应起来，都是8.5.1

![image.png](assets/1699928972-acc3e1e2ac1bedaf77c15cab41caaf7b.png)  
在官网备份有2种备份文件，第一种就是设置里面->备份与恢复->导出站点  
他得到的文件是restore打头的

![image.png](assets/1699928972-36c7c428b0ce291d8539d6153a7955c1.png)  
其中exportType为site，通过上述调试流程的判断，我们需要让exportType为ALL，因此我们选用另一个导出方案  
`/json/backup.action`

![image.png](assets/1699928972-12d5a2a78cb476125f8b72d96eb2589b.png)  
这个备份文件中主要内容是在entities.xml里，我们可以粗略的看看

![image.png](assets/1699928972-304de7ddab19919215a237b1e0b5a9aa.png)  
这样导出的就是all了，之后我们进行覆盖。

![image.png](assets/1699928972-da841c469d12d35735c7b91a88cd2d68.png)

![image.png](assets/1699928972-fa74e8532c8ff27ab0b4e3c8df05fd04.png)  
然后等待一会儿，就可以发现用户名密码和空间内容被我们覆盖

![image.png](assets/1699928972-a0496478b575a503e6972ee4db90ce14.png)  
^^，然后就是rce的问题

## 后台插件RCE

[https://github.com/AIex-3/confluence-hack/tree/main](https://github.com/AIex-3/confluence-hack/tree/main)  
后台提供了插件功能

![image.png](assets/1699928972-38c7273aed66b89fa1c3632b6e139f8b.png)  
我们可以上传自定义插件，github上有人做了一个恶意插件

![image.png](assets/1699928972-460c94269992366a9a4c5834bc983ea2.png)

![image.png](assets/1699928972-6594eae7d7dad8d8f0154e8aed9abfad.png)  
成功rce咯~CVE-2023-22515也是这样后台RCE的，但这个毕竟不是完整的TTY，假如服务不出网，我们还是需要修改一下插件的，最好能哥斯拉连接这样子。不过理论应该是可以的，只需要修改下逻辑- -  
看了一下它的源码

![image.png](assets/1699928972-de1076ede042e6ddc87dc9524e04a146.png)  
就是一个单纯的马，咱们传一个哥斯拉的马就行了OVO

# 失败的Getshell尝试

再说说失败的getshell方式吧，一开始我是逆向分析的，而不是正向分析的，因为当时不知道confluence有备份文件这东西，所以就自己手动构造了一下zip包，也是希望这个失败的思路可以给大家一点思路，个人觉得还是比较有趣的。这里就说一下我逆向的思路

![image.png](assets/1699928972-21b174b2b3b32226a9d1d22e46e3b934.png)

![image.png](assets/1699928972-c2df123866142d5a4579a1bebecb411d.png)  
我准备了一个zipslip的压缩包，由于上面说到了这个zip需要entities.xml和properties属性文件，然后xml就是随便给了一个大标签，是没有任何内容的，紧接着就进入断点判断了。

获取到了属性文件properties就会进入doRestore方法去进行恢复

![image.png](assets/1699928972-6c9e7f9f0ce659cf6fc82581e18b7871.png)

这个isSynchronous就是我们get传入的参数，我们要让他为true才可以进入task.run

![image.png](assets/1699928972-5a58e1a5c5688114ab938a8e7718c5eb.png)  
这个context是一个DefalutImportContext对象，所以之后task.run运行的逻辑应该在里面

![image.png](assets/1699928972-4c1b28b2767f8ebdce3cd782957303e5.png)

进入了doImport方法，然后有个preImport进行解压处理。

![image.png](assets/1699928972-6cec9fa9373c100b022eb91afa191d47.png)

![image.png](assets/1699928972-e6e2261a7718fd5661cff324907b7fef.png)  
最后自然就到了unzip方法

![image.png](assets/1699928972-05d55c1083c3e9fc0d635a5e4152f604.png)  
我以为在SaveEntity这里可以进行zipslip操作的。QWQ

![image.png](assets/1699928972-0349c13e9caacf9b0d9883115efa7674.png)

![image.png](assets/1699928972-337cbad0729a39469fbacb9db0468e7e.png)  
结果有一层判断isChildOf，导致我们的zipslip失败呜呜呜呜

# 总结

总得来说这漏洞是一个自爆式百分百损失的漏洞，你假如想用，那么就拿不到服务器那边原来的数据，而我们打Confluence的站一般都是去看他的文库数据，而不是获取这个站点的shell，这是一种比较极端的利用方式，不太建议使用，除非已知文库没啥东西，就是想要这个shell。
