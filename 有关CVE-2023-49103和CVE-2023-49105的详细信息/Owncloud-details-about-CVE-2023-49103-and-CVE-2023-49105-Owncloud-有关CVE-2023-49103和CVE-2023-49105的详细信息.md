

# Owncloud: details about CVE-2023-49103 and CVE-2023-49105 --- Owncloud：有关CVE-2023-49103和CVE-2023-49105的详细信息

![Full Article](assets/1704848583-8825d63dd48e8796bfc4e6ea144611ad.png)

# Introduction 介绍

On November 21th 2023, Owncloud released a new version patching two vulnerabilities ([1](https://owncloud.com/security-advisories/disclosure-of-sensitive-credentials-and-configuration-in-containerized-deployments/) and [2](https://owncloud.com/security-advisories/webdav-api-authentication-bypass-using-pre-signed-urls/)) we reported a few weeks before. The vulnerabilities were assigned [CVE-2023-49103](https://nvd.nist.gov/vuln/detail/CVE-2023-49103) and [CVE-2023-49105](https://nvd.nist.gov/vuln/detail/CVE-2023-49105).  
2023年11月21日，Owncloud发布了一个新版本，修补了我们几周前报告的两个漏洞（1和2）。这些漏洞被分配为CVE-2023-49103和CVE-2023-49105。

*Note: We performed the security assessment on dockerized Owncloud 10.12.2.  
注意：我们在dockerized Owncloud 10.12.2上执行了安全评估。*

# CVE-2023-49103: A slippery PHPinfo  
CVE-2023-49103：一个光滑的PHPinfo

One of the advisories mentioned a **PHPinfo** bug which boasted a **CVSS of 10 out of 10**. Indeed, on *docker* installs, if one could reach the PHPinfo page, they'd get access to every environment variable, and juicy secrets such as the username and password of the ownCloud administrator. As soon as it came up, it received lots of attention ~and an equal number of bad takes~.  
其中一个评论提到了一个PHPinfo bug，它的CVSS为10分。事实上，在Docker安装中，如果可以访问PHPinfo页面，他们就可以访问每个环境变量，以及诸如ownCloud管理员的用户名和密码之类的多汁秘密。它一出现，就受到了大量的关注~和同样数量的坏镜头~。

Although reaching the file directly yields a redirect, appending anything that looks like a resource allow access:  
虽然直接访问文件会产生重定向，但附加任何看起来像资源的内容都允许访问：

```plain
http://docker.local/apps/graphapi/vendor/microsoft/microsoft-graph/tests/GetPhpInfo.php/a.css
```

With this horror out of the way, let's talk about the vulnerability that should have **gotten the attention** instead.  
有了这个恐怖的方式，让我们谈谈脆弱性，应该得到的注意，而不是。

# CVE-2023-49105: Privilege escalation, remote code execution  
CVE-2023-49105：安全升级，远程代码执行

This bug, which is not related to docker, got a **CVSS of 9.8**. It affects every single ownCloud from version **10.6.0** to version **10.13.0**. Regrettably, [ownCloud's advisory](https://owncloud.com/security-advisories/webdav-api-authentication-bypass-using-pre-signed-urls/) is not precise enough, and only describes part of the impact for unauthenticated users.  
这个bug与docker无关，CVSS为9.8。它影响从版本10.6.0到版本10.13.0的每个ownCloud。遗憾的是，ownCloud的建议不够精确，只描述了对未经身份验证的用户的部分影响。

The real impact is twofold:  
真实的影响是双重的：

-   Attackers with no account can take control (CRUD) of **every file of any account**. In some cases, they may be able to **RCE**.  
    没有帐户的攻击者可以控制（CRUD）任何帐户的每个文件。在某些情况下，他们可能会RCE。
-   Attackers that have credentials of a standard account can **escalate** to **administrator** and get **RCE**.  
    拥有标准帐户凭据的攻击者可以升级到管理员并获得RCE。

Let's first start with the unauthenticated attack.  
让我们先从未经认证的攻击开始。

## From anonymous to user (and RCE)  
从匿名到用户（和RCE）

When issuing requests to some parts of the website, including the WEBDAV and CALDAV, users can authenticate by providing a username and a signature. The signature is computed from a **user-specific key** and elements from the HTTP request, such as the GET parameters, the HTTP method, *etc.* Sadly, by default, users do not have a key set. Their **signing key**, in this case, **defaults to a blank string**. As a result, an unauthenticated attacker can **impersonate any user** if they know their username.  
当向网站的某些部分（包括WEBDAV和CALDAV）发出请求时，用户可以通过提供用户名和签名进行身份验证。签名是从用户特定的密钥和HTTP请求中的元素（如GET参数、HTTP方法等）计算出来的。在这种情况下，它们的签名密钥默认为空字符串。因此，未经身份验证的攻击者可以冒充任何用户，如果他们知道他们的用户名。

Accessing WEBDAV as an attacker has incredible potential: **one could read, create, modify, or delete any file** a user possesses on the server. Someone said **ransomware**?  
WEBDAV作为攻击者具有令人难以置信的潜力：可以读取，创建，修改或删除用户在服务器上拥有的任何文件。有人说勒索软件？

Even scarier: whenever you upload files of certain types (images, for instance), a preview gets generated. For specific file formats, ownCloud uses **ImageMagick** to generate said preview. If the library is not up to date, an attacker will get **remote code execution**.  
更可怕的是：每当你上传某些类型的文件（例如图像）时，都会生成一个预览。对于特定的文件格式，ownCloud使用ImageMagick来生成所述预览。如果库不是最新的，攻击者将获得远程代码执行。

However, if Imagemagick is not vulnerable, and you already **have an account**, there is another way to get RCE: **escalating** your privileges to full **admin**.  
但是，如果Imagemagick不容易受到攻击，并且您已经有一个帐户，则还有另一种方法可以获得RCE：将您的权限升级为完全管理员。

## From user to admin (and RCE)  
从用户到管理员（和RCE）

Sadly for attackers, user settings and the administration panel cannot be accessed using signed URLs. To understand why, let's check the code that handles the authentication through this mean:  
不幸的是，攻击者无法使用签名的URL访问用户设置和管理面板。为了理解为什么，让我们检查通过这种方式处理身份验证的代码：

```plain
# /apps/dav/lib/Connector/Sabre/Auth.php

$verifier = new Verifier($request, $this->config);
if ($verifier->isSignedRequest()) {
    if (!$verifier->signedRequestIsValid()) {
        return [false, 'Invalid url signature'];
    }
    // TODO: setup session ???
    $urlCredential = $verifier->getUrlCredential();
    $user = \OC::$server->getUserManager()->get($urlCredential);
    if ($user === null) {
        $message = \OC::$server->getL10N('dav')->t('User unknown');
        throw new LoginException($message);
    }
    if (!$user->isEnabled()) {
        $message = \OC::$server->getL10N('dav')->t('User disabled');
        throw new LoginException($message);
    }
    $this->userSession->setUser($user); // <--- here
    \OC_Util::setupFS($urlCredential);
    $this->session->close();
    return [true, $this->principalPrefix . $urlCredential];
}
```

If the signature is valid, `Session::setUser()` gets called:  
如果签名有效，则调用 `Session::setUser()` ：

```plain
public function setUser($user) {
    if ($user === null) {
        $this->session->remove('user_id');
    } else {
        $this->session->set('user_id', $user->getUID());
    }
    $this->activeUser = $user;
}
```

`user_id` is the *only* session variable that gets set when authenticating using a signed URL. It stores the name of the logged-in user.  
`user_id` 是在使用签名URL进行身份验证时设置的唯一会话变量。它存储登录用户的名称。

Now, if we try to reach a "standard" page of the website, for instance user settings, the authentication is checked like so:  
现在，如果我们尝试访问网站的“标准”页面，例如用户设置，则会像这样检查身份验证：

```plain
if (\OC::$server->getUserSession()) {
    $request = \OC::$server->getRequest();
    $session = \OC::$server->getUserSession();
    $davUser = \OC::$server->getUserSession()->getSession()->get('AUTHENTICATED_TO_DAV_BACKEND');
    if ($davUser === null) {
        $session->validateSession();
    } else {
        ...
    }
}
```

Since `AUTHENTICATED_TO_DAV_BACKEND` is not set in our case, we end up in `validateSession()`, which checks that the session has a valid token. Since no token is set, we are logged out: we can't access "standard pages" using only this bug.  
由于在我们的例子中没有设置 `AUTHENTICATED_TO_DAV_BACKEND` ，我们最终进入 `validateSession()` ，它检查会话是否有有效的令牌。由于没有设置令牌，我们被注销了：我们不能只使用这个bug访问“标准页面”。

However, we could look to elevate our privileges by logging in as a standard user, and then spoofing our `user_id` to `admin`: we'd keep the old session variables (such as `AUTHENTICATED_TO_DAV_BACKEND`), and would just change our ID.  
但是，我们可以通过以标准用户身份登录来提升我们的权限，然后将 `user_id` 欺骗为 `admin` ：我们将保留旧的会话变量（例如 `AUTHENTICATED_TO_DAV_BACKEND` ），而只是更改我们的ID。

Sadly, further down the authentication process, `verifyAuthHeaders()` gets called. It checks that the user is **properly authenticated**.  
不幸的是，在身份验证过程中，会调用 `verifyAuthHeaders()` 。它检查用户是否经过正确的身份验证。

```plain
class Session implements IUserSession, Emitter {
    ...

    public function verifyAuthHeaders($request) {
        $shallLogout = false;
        try {
            ...

            foreach ($this->getAuthModules(true) as $module) {
                $user = $module->auth($request); # [1]
                if ($user !== null) {
                    if ($this->isLoggedIn() && $this->getUser()->getUID() !== $user->getUID()) { // [2]
                        $shallLogout = true;
                        break;
                    }
                    ...
                }
            }
        } catch (Exception $ex) {
            $shallLogout = true;
        }
        if ($shallLogout) { # [3]
            // the session is bad -> kill it
            $this->logout();
            return false;
        }
        return true;
    }
}
```

If an authentication module is able to authenticate a user \[1\], ownCloud makes sure that the user returned by the module matches the one stored in the `user_id` session key \[2\]. If it does not, we're logged out \[3\].  
如果认证模块能够认证用户 \[1\] ，则ownCloud确保模块返回的用户与存储在 `user_id` 会话密钥 \[2\] 中的用户相匹配。如果没有，我们将退出 \[3\] 。

The only way to bypass this check is to make the `auth()` method of the module that authenticates us, `TokenAuthModule`, return `null`, despite having a valid session.  
绕过此检查的唯一方法是使验证我们的模块的 `auth()` 方法 `TokenAuthModule` 返回 `null` ，尽管具有有效会话。

```plain
class TokenAuthModule implements IAuthModule {
    ...

    public function auth(IRequest $request) {
        ...
        $dbToken = $this->getToken($request, $token); # [1]
        if ($dbToken === null) {
            return null;
        }
        ...
        $uid = $dbToken->getUID();
        return $this->manager->get($uid);
    }

    private function getToken(IRequest $request, &$token) {
        $authHeader = $request->getHeader('Authorization'); # [2]
        if ($authHeader === null || \strpos($authHeader, 'token ') === false) {
            // No auth header, let's try session id
            try {
                $token = $this->session->getId();
            } catch (SessionNotAvailableException $ex) {
                return null;
            }
        } else {
            $token = \substr($authHeader, 6);
        }

        try {
            return $this->tokenProvider->getToken($token);
        } catch (InvalidTokenException $ex) {
            $token = null;
            return null;
        }
    }
}
```

We therefore need to make `getToken()` return NULL \[1\]. Luckily, the latter checks whether a token is present in the `Authorization` header *before* checking if a valid session is present \[2\]. By providing an incorrect token through this header, we can make `TokenAuthModule::auth()` return NULL despite being logged in, and thus bypass the username check.  
因此，我们需要使 `getToken()` 返回NULL \[1\] 。幸运的是，后者在检查是否存在有效会话之前检查 `Authorization` 头中是否存在令牌 \[2\] 。通过在这个头中提供一个不正确的token，我们可以让 `TokenAuthModule::auth()` 在登录时返回NULL，从而绕过用户名检查。

The resulting privilege escalation procedure is as so:  
由此产生的权限提升过程如下：

-   Log in as a standard user  
    以标准用户身份登录
-   Use the URL-signing mechanism to spoof your `user_id`  
    使用URL签名机制欺骗您的 `user_id`
-   Access any page with `Authorization: token thisisnotavalidtoken`  
    使用 `Authorization: token thisisnotavalidtoken` 访问任何页面

This allows you to get from a **normal user to the admin account**. From there, there are various ways to get **remote code execution**. These are left as an exercise to the reader.  
这允许您从普通用户到管理员帐户。从那里，有各种方法可以获得远程代码执行。这些都是留给读者的练习。

# Conclusion 结论

*CVE-2023-49105* allows you to either **get complete access to the files of any user** (and potentially, get RCE), or if you already have an account, **escalate your privileges to admin**, paving the way for **remote code execution**. The other, *CVE-2023-49103*, is a PHPinfo.  
CVE-2023-49105允许您完全访问任何用户的文件（并可能获得RCE），或者如果您已经有帐户，则将您的权限升级到管理员，为远程代码执行铺平道路。另一个，CVE-2023-49103，是一个PHPinfo。

The exploits are available [here](https://github.com/ambionics/owncloud-exploits).  
这些漏洞可以在这里找到。

# Demo 演示

This video shows how an unauthenticated attacker gets access to the files of any user.  
此视频展示了未经身份验证的攻击者如何访问任何用户的文件。

# We're hiring! 我们在招人！

Ambionics is an entity of [Lexfo](https://www.lexfo.fr/), and we're hiring! To learn more about job opportunities, do not hesitate to contact us at [rh@lexfo.fr](mailto:rh@lexfo.fr). *We're a french-speaking company, so we expect candidates to be fluent in our beautiful language.*  
Ambionics是Lexfo的一个实体，我们正在招聘！要了解更多关于工作机会的信息，请不要犹豫，通过rh@lexfo. fr与我们联系。我们是一家讲法语的公司，所以我们希望应聘者能流利地使用我们美丽的语言。
