

# Apache OFBiz CVE-2023-49070 & 最新 CVE-2023-51467 未授权分析（RCE/SSRF/LFR） - 先知社区

Apache OFBiz CVE-2023-49070 & 最新 CVE-2023-51467 未授权分析（RCE/SSRF/LFR）

- - -

## 写在前面

最近看到 P 神公众号上发了篇 Apache Ofbiz 的漏洞分析所以就跟着学习了一下，没想到长亭这两天马上就又发布了鉴权绕过导致的几个利用 CVE，于是也跟着做了些分析。

## CVE-2023-51467（学习鉴权绕过）

-   漏洞影响范围：Apache OFBiz < 18.12.10
-   测试版本：Apache OFBiz 18.12.9
-   漏洞复现  
    POC：网上已经公开了就不粘贴了（粘上来显示不出来不知道为啥）  
    [![](assets/1704158305-2a6c22c2ddf4f9fdf9d40d8ae68eb7f8.png)](https://xzfile.aliyuncs.com/media/upload/picture/20231228114037-dd5f92ae-a532-1.png)
-   漏洞绕过分析  
    从两方面绕过：
    -   绕过对于 `</serializable` 这个关键词的检测
    -   绕过对 XML-RPC 这个接口的认证  
        直接从之前补丁位置开始分析 `org.apache.ofbiz.base.util.CacheFilter#doFilter`  
        [![](assets/1704158305-a28895b8a8b07184c8129cc53a40b6ce.png)](https://xzfile.aliyuncs.com/media/upload/picture/20231228114244-28da6f42-a533-1.png)  
        首先看到 uri 为 `/control/xmlrpc/;/` 从而绕过针对 `</serializable` 标签的检查。  
        [https://www.baeldung.com/cs/url-matrix-vs-query-parameters#tcp-connection](https://www.baeldung.com/cs/url-matrix-vs-query-parameters#tcp-connection) 提到了 ; 的含义。  
        因此，我们这里绕过了 `serializable` 的限制，接下来还需要绕过认证的模块。这一部分代码逻辑是在调用 `runEvent` 方法时进行。  
        具体在 `org.apache.ofbiz.webapp.control.LoginWorker#checkLogin` 这里条件分支当中的 `login` 函数非常关键，其返回值是否等于 error 决定了是否可以绕过鉴权。  
        [![](assets/1704158305-93b9e02fe712277a942698da7bb81252.png)](https://xzfile.aliyuncs.com/media/upload/picture/20231228114456-776c3d34-a533-1.png)  
        跟进 login，这个绕过逻辑其实很简单，用于用户名为空，所以 `unpwErrMsgList` 当中会添加提示信息，使得走入下面这个条件分支，而在返回时，因为我们设置了 `requirePasswordChange` 参数值为 Y，因此返回的则是 `requirePasswordChange` ，不再是 `error`。  
        [![](assets/1704158305-3ab29d184fa43e82abb1ee75593c40eb.png)](https://xzfile.aliyuncs.com/media/upload/picture/20231228114543-93d2c1dc-a533-1.png)  
        最终绕过 login 认证  
        [![](assets/1704158305-2b0812f076208c971668b21fe023b994.png)](https://xzfile.aliyuncs.com/media/upload/picture/20231228114628-aead4a86-a533-1.png)
-   漏洞修复  
    [https://github.com/apache/ofbiz-framework/commit/c59336f604f503df5b2f7c424fd5e392d5923a27](https://github.com/apache/ofbiz-framework/commit/c59336f604f503df5b2f7c424fd5e392d5923a27)  
    修复直接暴力移除了 xmlrpc 模块  
    [![](assets/1704158305-c8a321eea05978292d35084d0a9922fe.png)](https://xzfile.aliyuncs.com/media/upload/picture/20231228114643-b75ba88a-a533-1.png)  
    \## CVE-2023-51467 （RCE / SSRF / LFR）
-   漏洞影响版本：Apache Ofbiz < 18.12.11
-   测试版本：18.12.10  
    \#### grovvy RCE  
    这个一开始我没有发现，因为 git diff 当中没有找到相关的接口，后来看到 y4tacker 大师傅发了篇文章 [https://y4tacker.github.io/2023/12/27/year/2023/12/Apache-OFBiz%E6%9C%AA%E6%8E%88%E6%9D%83%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%B5%85%E6%9E%90-CVE-2023-51467/](https://y4tacker.github.io/2023/12/27/year/2023/12/Apache-OFBiz%E6%9C%AA%E6%8E%88%E6%9D%83%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%B5%85%E6%9E%90-CVE-2023-51467/) 于是就跟着复现了一下。  
    存在问题的接口在 `/webtools/control/ProgramExport` 依然在之前 webtools 目录下，因此映射的 servlet 都是一样的。  
    org.apache.ofbiz.webapp.control.RequestHandler#doRequest 下会根据配置解析请求映射。  
    [![](assets/1704158305-b3324af7762f22684d07fca0535986fa.png)](https://xzfile.aliyuncs.com/media/upload/picture/20231228114947-254fecd4-a534-1.png)  
    具体可以在 controller.xml 下找到，看到这里是作了鉴权的（但是已经被我们绕过了），并且并没有 event handler 的设置，只设置了响应信息，类型为 view。  
    [![](assets/1704158305-fb1a7bd7839edb7566d7f4f00a238eb9.png)](https://xzfile.aliyuncs.com/media/upload/picture/20231228114944-2381ec68-a534-1.png)  
    因此处理完请求后，会根据 `nextRequestResponse.type` 的值来渲染视图。  
    [![](assets/1704158305-6a6c932d4310cd0464c2fcb268580d71.png)](https://xzfile.aliyuncs.com/media/upload/picture/20231228115042-462f7bea-a534-1.png)  
    来到 org.apache.ofbiz.webapp.control.RequestHandler#renderView ，可以看到视图配置也是从 controller.xml 中读取。  
    [![](assets/1704158305-95920f33a25d68804190e8e492d87527.png)](https://xzfile.aliyuncs.com/media/upload/picture/20231228115114-592ae158-a534-1.png)  
    这里如果不熟悉 Ofbiz 视图配置的话可以看文档这里：[https://cwiki.apache.org/confluence/display/OFBIZ/Understanding+the+OFBiz+Widget+Toolkit](https://cwiki.apache.org/confluence/display/OFBIZ/Understanding+the+OFBiz+Widget+Toolkit)  
    [![](assets/1704158305-80e21c2c476968cadc2f72cbe2ef0e0a.png)](https://xzfile.aliyuncs.com/media/upload/picture/20231228115140-68865e8e-a534-1.png)  
    另外如果不熟悉 groovy 的话可以先看看这篇 [https://xz.aliyun.com/t/8231#toc-5](https://xz.aliyun.com/t/8231#toc-5)  
    groovy 脚本的执行参数可以通过在 `context` 中设置，这里意思也就是可以在请求参数中设置。  
    根据脚本内容可以知道参数名设置为 `groovyProgram` 即可。  
    调用栈如下：  
    [![](assets/1704158305-0ca02e2f48cb42fd945925ffc36f58fe.png)](https://xzfile.aliyuncs.com/media/upload/picture/20231228115222-81bf7be2-a534-1.png)  
    跟入 groovy 脚本，里面对输入参数作了一些检查，调用 `SecuredUpload.isValidText` 。  
    [![](assets/1704158305-4096256916210d253381f8e5c658f994.png)](https://xzfile.aliyuncs.com/media/upload/picture/20231228115239-8b8db6fc-a534-1.png)  
    黑名单如下所示，白名单为 import 关键字。  
    [![](assets/1704158305-44105187fd69f27cea2f30c9866d91d9.png)](https://xzfile.aliyuncs.com/media/upload/picture/20231228115300-985cd5c0-a534-1.png)  
    这个过滤其实很不严，比如 execute 都没有过滤掉，配合字符串拼接就可以执行任意命令了。  
    [![](assets/1704158305-203883ddfa6c623737c21444e3b90211.png)](https://xzfile.aliyuncs.com/media/upload/picture/20231228115318-a2f5d414-a534-1.png)  
    \#### SSRF && 任意配置读取
-   git diff  
    [https://github.com/apache/ofbiz-framework/commit/d8b097f6717a4004acf023dfe929e0e41ad63faa](https://github.com/apache/ofbiz-framework/commit/d8b097f6717a4004acf023dfe929e0e41ad63faa)
    
    > Replaced direct null checks on username, password, and token with UtilValidate.isEmpty() method calls for consistency
    

[![](assets/1704158305-026a9156b738b9c57105b68579cbd937.png)](https://xzfile.aliyuncs.com/media/upload/picture/20231228115448-d8997d64-a534-1.png)  
这个也就是前面漏洞提到鉴权的地方，前面是空字符串可以绕过，这里改换成了 UtilValidate.isEmpty() 看下它里面还判断了字符串长度，因此使用空字符串不再可以绕过。  
[![](assets/1704158305-42d433f527d1a72b03e57cbebf6ec3c4.png)](https://xzfile.aliyuncs.com/media/upload/picture/20231228115505-e26f8ab8-a534-1.png)  
[https://github.com/apache/ofbiz-framework/commit/82c17376880a8fd8a11261e1e00dad45cfed344d](https://github.com/apache/ofbiz-framework/commit/82c17376880a8fd8a11261e1e00dad45cfed344d)

> Use screen engine for the request getJSONuilabels

themes/common-theme/webapp/common/js/util/OfbizUtil.js  
[![](assets/1704158305-e4bc04aeff872ffbd0dc2d5035f34628.png)](https://xzfile.aliyuncs.com/media/upload/picture/20231228115546-faf000c2-a534-1.png)  
diff 当中看到两个 js 文件，`getJSONuilLabels` 函数里面通过 jQuery 发送请求到 `getJSONuiLabelArray` API ，请求方式为 POST ，并且传参 `requiredLabels` 。  
然后 PartyProfileContent.js 当中看到调用了该 `getJSONuilLabels` 方法，传的格式为 json 。  
applications/party/webapp/partymgr/static/PartyProfileContent.js  
[![](assets/1704158305-eb043764cdc86d874b80486b7926de30.png)](https://xzfile.aliyuncs.com/media/upload/picture/20231228115612-0a9a988e-a535-1.png)  
根据变量名 UiLabel 我们可以大致推理出这里是在做一个国际化处理，即发送标签名并从与 CommonUiLabels 关联的配置文件当中读取相应标签名的国际化信息并返回。  
OK 我们可以尝试发起这个请求验证一下。一番查找之后这个接口是对应的是 `webtools/control/getJSONuiLabelArray`  
[![](assets/1704158305-d4de4be25f0beaa5fc970d2baf2c2391.png)](https://xzfile.aliyuncs.com/media/upload/picture/20231228115700-26ef35da-a535-1.png)  
感兴趣的话可以看下这个默认国际化配置文件信息就在 framework/common/config/CommonUiLabels.xml。  
`getJSONuiLabelArray` 路由信息位于 framework/common/webcommon/WEB-INF/common-controller.xml。  
[![](assets/1704158305-cb1630fd03d7793036313ed26b1f8126.png)](https://xzfile.aliyuncs.com/media/upload/picture/20231228115748-43982138-a535-1.png)  
可以看到 https 设置为 true，说明这里调用也是需要先鉴权的（因此需要我们先做鉴权绕过）。之后的事件处理 handler 为 CommonEvents 类。  
[![](assets/1704158305-f199a9d2db7cc22e301d037c6989ea75.png)](https://xzfile.aliyuncs.com/media/upload/picture/20231228115821-573810a4-a535-1.png)  
其实这里思路已经有了，就是看看这个配置文件是否是可以指定的，因为所有的参数都可以控制。因此分析的主要逻辑在 `org.apache.ofbiz.base.util.UtilProperties#getResourceBundle` 这里，第一个参数就是前面 `CommonUiLabels` 对应位置值。  
首先会调用 `createResourceName` 方法，里面第三个参数如果为 true 的话，会移除后缀出现 `.xml/.properties` 的（后面还会出现）。并且将 locale 本地信息添加到后缀。  
[![](assets/1704158305-606a130d9492dc15f88561c8f72738d4.png)](https://xzfile.aliyuncs.com/media/upload/picture/20231228115851-69636a08-a535-1.png)  
之后如果 `bundleCache` 中没有对应项的话，则会去掉之前添加的 locale 本地信息后缀，换一个其他的，这里看到 locale 本地信息是存在空字符串的，也就是什么都不添加。然后再去查找，如果还没有则会调用 `getProperties` 方法。  
[![](assets/1704158305-b1e3877484320c78959f2eff9c4246df.png)](https://xzfile.aliyuncs.com/media/upload/picture/20231228115924-7d347324-a535-1.png)  
org.apache.ofbiz.base.util.UtilProperties#getProperties(java.lang.String, java.util.Locale) 可以看到会调用 `resolvePropertiesUrl` 解析 `resource` 的 url。里面实际还会调用一次 `createResourceName` ，这回第三个参数变成了 false，也就是不会去除后缀。因此可以任意指定加载配置文件。  
[![](assets/1704158305-79c27cb339e9a07497601b1422dadc71.png)](https://xzfile.aliyuncs.com/media/upload/picture/20231228120004-95104824-a535-1.png)  
可以看到这里支持多种协议，包括常见的 http/file 协议。  
[![](assets/1704158305-fb3930f5d4b2bd659d4bde8ad5e1e36c.png)](https://xzfile.aliyuncs.com/media/upload/picture/20231228120024-a08df0ac-a535-1.png)  
然后如果是指定了某个协议时， org.apache.ofbiz.base.util.UtilProperties#resolvePropertiesUrl 就会创建一个 URL 实例。  
[![](assets/1704158305-55bdc58cf5e934d608ec110e35718e0c.png)](https://xzfile.aliyuncs.com/media/upload/picture/20231228120048-af45b526-a535-1.png)  
后续 org.apache.ofbiz.base.util.UtilProperties.ExtendedProperties#ExtendedProperties(java.net.URL, java.util.Locale) 就会建立连接并读取其中的内容。因此这里就是文件读取以及 SSRF 的漏洞 sink 点。  
[![](assets/1704158305-812654114df6efb3d6f0da9328c3f5a1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20231228120104-b89f4268-a535-1.png)  
它这里支持读取 properties 或 xml 文件，我们这里以 properties 为例。  
那么内容如何解析并回显呢？来到 `org.apache.ofbiz.base.util.UtilProperties#getMessage(java.lang.String, java.lang.String, java.util.Locale)` 方法，这里看到只需要读取的键值对中，key 存在与 `name`（就是对应的前面传入的标签值）一样的话就取出并回显。  
[![](assets/1704158305-de30092ecb469f80a929caac7e25d8ff.png)](https://xzfile.aliyuncs.com/media/upload/picture/20231228120150-d422530e-a535-1.png)  
**配置文件读取**  
以读取 applications/accounting/config/payment.properties 中的几个 key 为例  
[![](assets/1704158305-339c349d83508dc8793e466ea03acd8f.png)](https://xzfile.aliyuncs.com/media/upload/picture/20231228120221-e6d0e0b0-a535-1.png)  
**SSRF 利用**  
这里随便写一个 properties 文件，然后 `python -m http.server 8000` 起个服务  
[![](assets/1704158305-7d38e044b78cf8abcf4028c038a34b4a.png)](https://xzfile.aliyuncs.com/media/upload/picture/20231228120251-f8b1eac2-a535-1.png)  
POC 验证  
[![](assets/1704158305-d75ce94c3fce345de63d8dce52b75d12.png)](https://xzfile.aliyuncs.com/media/upload/picture/20231228120316-075888ba-a536-1.png)  
成功对 8000 端口服务发起了请求  
[![](assets/1704158305-13ef05a81667fc4034ae97b18252ad05.png)](https://xzfile.aliyuncs.com/media/upload/picture/20231228120332-10d93c5e-a536-1.png)

#### 引用

\[1\] [Insecure Deserialization in Apache XML-RPC · CVE-2019-17570 · GitHub Advisory Database](https://github.com/advisories/GHSA-6vwp-35w3-xph8)  
\[2\] [CVE-2023-49070&&CVE-2020-9496 OFBIZ XML-RPC漏洞分析 - 先知社区 (aliyun.com)](https://xz.aliyun.com/t/13168)  
\[3\] [https://mp.weixin.qq.com/s/iAvitO6otPdHSu1SjRNX3g](https://mp.weixin.qq.com/s/iAvitO6otPdHSu1SjRNX3g)  
\[4\] [https://www.mi1k7ea.com/2021/09/21/浅析Ofbiz反序列化漏洞（CVE-2020-9496）/](https://www.mi1k7ea.com/2021/09/21/%E6%B5%85%E6%9E%90Ofbiz%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%EF%BC%88CVE-2020-9496%EF%BC%89/)  
\[5\] [https://xz.aliyun.com/t/8184#toc-3](https://xz.aliyun.com/t/8184#toc-3)  
\[6\] [The Apache OFBiz® Project - Release Notes 18.12.11](https://ofbiz.apache.org/release-notes-18.12.11.html)  
\[7\] [Apache OFBiz未授权命令执行浅析(CVE-2023-51467) (y4tacker.github.io)](https://y4tacker.github.io/2023/12/27/year/2023/12/Apache-OFBiz%E6%9C%AA%E6%8E%88%E6%9D%83%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%B5%85%E6%9E%90-CVE-2023-51467/)
